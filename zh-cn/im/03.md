在像IM这样的长连接应用场景中,如何保持连接,检测连接是否正常,异常情况下连接断开如何重新连上是个非常重要的课题,为什么说很重要了有下面几个因素:

- 网络状况复杂,连接会经常中断,比如出入电梯
- 很多防火墙路由器等对于空闲socket自动关闭
- 对于非正常断开, 服务器并不能检测到. 为了回收资源, 必须提供一种检测机制.

而这个课题的通用解决方案就是心跳机制,也就是持续间隔的发送一些小的数据包,通过这些数据包来维持连接,并检测连接的可用性。就目前而言有两种方案来实现心跳机制：

- TCP协议层面支持的心跳机制Keepalive
- 应用层协议自己实现的心跳机制

这两种实现的原理都是我前面说的,但是就我个人了解的业内现状是IM方面几乎都采用第二种,我目前还没见过IM使用第一种的,但第一种我在一些对连接保持要求不高的应用场景下也见人用过，所以并不是说第一种就没有任何用处。下面我将详细分析这两种类似的实现的细微差别是如何导致最终大部分IM采用了应用层心跳的方案的。

1. TCP协议的KeepAlive

- 优点：使用起来简单, 减少了应用层代码的复杂度. 也会更节省流量, 因为应用层的数据传输到TCP协议层时都会被加上额外的包头包尾. 由TCP协议提供的检活, 其发的探测包, 理论上实现的会更精妙, 耗费更少的流量.
- 致命缺点:第一点,keepAlive只能检测连接存活,而不能检测连接可用,比如某台服务器因为某些原因导致负载超高,CPU满了,无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求;第二点,如果tcp连接的另一端突然掉线，这个时候我们并不知道网络已经关闭。而此时，如果有发送数据失败，tcp会自动进行重传。重传包的优先级高于keepalive的包，那就意味着，我们的keepalive总是不能发送出去。 而此时，我们也并不知道该连接已经出错而中断。在较长时间的重传失败之后，我们才会知道。

2.应用层的心跳包

- 优点:有着更大的灵活性，可以控制检测时机，间隔和处理流程，甚至可以在心跳包上附带额外信息,最重要的是可以做到没有上面所说的致命缺点,不光可以检测连接存在,还可以检测连接可用。
- 缺点:需要自己实现,有额外的工作量

经过以上的分析应该可以很清楚的了解到为什么现在大部分IM使用应用层心跳而不是tcp的keepAlive,当然应用层的心跳机制不单单是定时发包这么简单,还有很多有技巧的优化手段,之后会拿出一篇文章专门讲如何实现一套高效的心跳机制。