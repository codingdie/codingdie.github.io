### IM消息可靠性之2/4/6/N个报文分析  <!-- {docsify-ignore} -->

对于一个IM系统来讲,保证消息一定能到达是个非常重要的课题。一般来讲无非是收到消息后发送确认报文(ACK )。这个时候对于一些没接触IM系统但是知道TCP协议的人来讲可能就有个疑惑,TCP协议是可靠性协议,按理说基于TCP协议(或自己实现的可靠UDP)的IM系统,已经确保了数据一定能发到,为何还要我们自己实现ACK了。

首先我要理清大部分人可能混淆的一个概念：什么叫做消息一定能达到?

假设用户A发送给用户B一个消息MSG,对于消息被B收到了有两种理解：

- MSG数据被B接受到了 
- MSG数据被B接收到并消费(存入本地数据库)

TCP保证了第一点即数据一定会完整传输到B一次。但是在IM系统里面光是传输到是没有意义的,因为直到MSG被B最终保存下来是有过程的,这个过程中如果出现任何问题,最终业务上B就会认为丢消息,因为明明A发了但是B显示不出来。这种事情也不是小概率尤其是移动端,比如一进应用我立刻又推出如果没有机制处理的话肯定稳定丢消息。

一般如果问为什么有TCP还要自己实现聊天消息ACK资深研究IM工程师的回答会是:这两个不是一个层面的东西,一个是传输层,一个是应用层。这句话极度准确概括,但不容易理解。而具体原因通俗来讲就是我上面说的。

下面来继续说可靠性的消息

对于一个没有ACK的最简单的IM系统(2报文):

1. A->SERVER
2. SERVER->B

对于一个有ACK的IM系统:

1. A->SERVER
2. SERVER->A  (ACK)
3. SERVER->B
4. B->SERVER  (ACK)

比较需要注意的是这里面的ACK报文一定是在业务处理完了发,如果是在业务处理前发的话是不能保证业务以上不丢消息的。

这种机制下又引发另外一个问题：如果有ACK报文的话出错的时候会重发,但极端情况下,比如用户可能消息已经存到本地了,回执发送失败了,这个时候再次发的话本地就重复了,这个时间就需要进行客户端去重,策略很多,简单的话就每个消息一个ID来去重就行.

总结一下ACK+客户端去重保证IM消息不重不漏。

上面可以看到4个报文充分保证了消息不会丢失。那么6个报文是干什么的？

对于一些IM系统来说业务上不重不漏消息可能还不够,可能A发给B之后A还要知道B什么时候收到这个时候就需要增加两个报文来实现

1. A->SERVER
2. SERVER->A  (ACK)
3. SERVER->B
4. B->SERVER  (ACK)
5. SERVER->A  通知B收到了消息
6. A->SERVER     (ACK)

当然如果有更复杂的业务需求,比如还要知道B什么时候读的可以继续增加报文。理论N个报文.

这就是IM消息可靠性之2/4/6/N的演化过程